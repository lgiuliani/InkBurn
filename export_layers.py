#!/usr/bin/env python3
 # 
 # This file is part of the InkBurn distribution (https://github.com/lgiuliani/InkBurn).
 # Copyright (c) 2025 LLaurent Giuliani.
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #
import inkex
from pathlib import Path
from inkex import bezier
from inkex.transforms import Vector2d
from common import get_layer_name, is_visible, get_sorted_elements, list_layers, get_element_subpaths
import subprocess
from sys import platform
from os import startfile
import config_global

SMAX = 1000          # Maximum laser power
TRAVEL_SPEED = 4000  # mm/min for travel moves
CURVE_SAMPLE = 0.1   # mm per interpolation step for curves
COORD_PRECISION = 2  # Decimal precision for coordinate output
GCODE_SEPARATOR = ''  # Separator for G-code command parts

HEADER_GCODE = [
    '; Generated by Ink/Burn GCode Export',
    'G21 ; units mm',
    'G90 ; absolute coords',
    f'G0 F{TRAVEL_SPEED} ; set travel speed',
    'M4  ; laser on'
]

FOOTER_GCODE = [
    'M5 ; laser off',
    f'G0 X0 Y0 ; return to origin',
    'M2 ; end program'
]

def openfile(filename):
    """Open filename"""
    if platform == "win32":
        startfile(filename)
    else:
        opener = "open" if platform == "darwin" else "xdg-open"
        subprocess.call([opener, filename])

class ExportGCode(inkex.OutputExtension):
    """
    Optimized G-code generator with:
    - Redundant command elimination
    - Changed-axis-only output
    - State-aware motion commands
    - 
    """ 
    def store_point(self, point: Vector2d, command: str, power: int = None, speed: int = None ) -> list:
        """Add move command with optimized output"""            
        parts = []
        
        # Round coordinates before comparison and formatting to avoid duplicates
        x_rounded = round(point.x, COORD_PRECISION)
        y_rounded = round(point.y, COORD_PRECISION)
        
        # Add command type if changed
        if command != self.last_state['command']:
            parts.append(command)
            self.last_state['command'] = command

        # Add speed if changed
        if speed != self.last_state['speed'] or speed is not None :
            parts.append(f'F{speed}')
            self.last_state['speed'] = speed

        # Add power if changed
        if power != self.last_state['power'] or power is not None :
            parts.append(f'S{power}')
            self.last_state['power'] = power

        # Add coordinates that changed
        coords = []
        if self.last_state['x'] != x_rounded:
            coords.append(f'X{x_rounded:.{COORD_PRECISION}f}'.rstrip('0').rstrip('.'))
        if self.last_state['y'] != y_rounded:
            coords.append(f'Y{y_rounded:.{COORD_PRECISION}f}'.rstrip('0').rstrip('.'))
            
        if coords:
            parts.append(GCODE_SEPARATOR.join(coords))
        elif not parts:
            # Position didn't change and motion type same - nothing to output
            return []
            
        # Update position last_state with rounded values
        self.last_state['x'] = x_rounded
        self.last_state['y'] = y_rounded
        
        return [GCODE_SEPARATOR.join(parts)] if parts else []

    def process_element_to_gcode(self, elements: list, viewbox_height: float) -> list:
        """Convert a single SVG element to optimized G-code commands"""
        # Reset last_state tracking at layer start
        self.last_state = {'x': None, 'y': None, 'command': None, 'power': None, 'speed': None}

        commands = []
        for elem in elements:
            # Get subpaths with transforms applied
            superpath = get_element_subpaths(elem)
            if not superpath:
                continue
                    
            # Subdivide curves for smoother output
            bezier.cspsubdiv(superpath, CURVE_SAMPLE)
            
            # Add element comment
            comment = f"; {elem.tag_name} {elem.get('id', '')} {elem.get('d')}"
            commands.append(comment[:80])
            
            for subpath in superpath:
                # Move to path start with travel move
                x0, y0 = subpath[0][1]
                point = Vector2d (x0, viewbox_height - y0)
                if move_cmds := self.store_point(point, 'G0'):
                    commands.extend(move_cmds)
                
                # Process remaining points with cutting moves
                for point in subpath[1:]:
                    x, y = point[1]
                    point = Vector2d(x, viewbox_height - y)
                    if move_cmds := self.store_point(point, 'G1'):
                        commands.extend(move_cmds)
    
        return commands

    def process_layers(self) -> list:
        """Process all elements in all layers and return G-code commands"""
        self.preprocess()
        svg = self.document.getroot()
        layers = list_layers(svg)
        viewbox_height = svg.viewbox_height

        gcode = []
        for layer in layers:
            if not is_visible(layer):
                continue

            label = get_layer_name(layer)
            if layer.get('data-active', 'false').lower() != 'true':
                continue

            passes = int(layer.get('data-passes', '1'))
            speed = int(layer.get('data-speed', '0'))
            power = int(int(layer.get('data-power', '0')) * SMAX / 100)

            elements = get_sorted_elements(layer) 
            if not elements:
                inkex.utils.debug(f"No visible elements in layer '{label}'")
                continue
            commands = self.process_element_to_gcode(elements, viewbox_height)

            gcode.append(f'; Layer: {label} | Passes: {passes} | Speed: {speed} | Power: {power/10}%')
            for p in range(passes):
                gcode.append(f'; --- {label} - Pass {p+1}/{passes}')
                gcode.append(f'G1 F{speed} S{power}')
                gcode.extend(commands)
                gcode.append(f'G0 F{TRAVEL_SPEED}')
            
        return gcode

    def save(self, stream):
        gcode = HEADER_GCODE.copy()
        gcode += self.process_layers()
        gcode += FOOTER_GCODE

        outpath = Path(self.document_path() or '').with_suffix('.nc')
        outpath.write_text("\n".join(gcode), encoding='utf-8')

        # Autolaunch laser program if enabled in config
        try:
            cp = config_global.load_config()
            cfg = cp[config_global.CONFIG_SECTION]
            if cfg.get('autolaunch', 'false').lower() == 'true':
                try:
                    openfile(str(outpath))
                except Exception as e:
                    inkex.utils.debug(f"Autolaunch failed: {e}")
        except Exception as e:
            inkex.utils.debug(f"Failed to read config for autolaunch: {e}")

if __name__ == '__main__':
    ExportGCode().run()
