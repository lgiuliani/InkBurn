#!/usr/bin/env python3
 # 
 # This file is part of the InkBurn distribution (https://github.com/lgiuliani/InkBurn).
 # Copyright (c) 2025 LLaurent Giuliani.
 # 
 # This program is free software: you can redistribute it and/or modify  
 # it under the terms of the GNU General Public License as published by  
 # the Free Software Foundation, version 3.
 #
 # This program is distributed in the hope that it will be useful, but 
 # WITHOUT ANY WARRANTY; without even the implied warranty of 
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License 
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #
import inkex
from pathlib import Path
from inkex.transforms import Transform
from inkex import bezier
from common import get_layer_name, is_visible, get_sorted_elements, list_layers

SMAX = 1000          # Maximum laser power
TRAVEL_SPEED = 4000  # mm/min for travel moves
CURVE_SAMPLE = 0.1   # mm per interpolation step for curves
COORD_PRECISION = 2  # Decimal precision for coordinate output
GCODE_SEPARATOR = ''  # Separator for G-code command parts
# KERF_WIDTH = 0.1
DEBUG = 0

HEADER_GCODE = [
    '; Generated by Ink/Burn GCode Export',
    'G21 ; units mm',
    'G90 ; absolute coords',
    f'G0 F{TRAVEL_SPEED} ; set travel speed',
    'M4  ; laser on'
]

FOOTER_GCODE = [
    'M5 ; laser off',
    f'G0 X0 Y0 ; return to origin',
    'M2 ; end program'
]

class ExportGCode(inkex.Effect):
    """
    Optimized G-code generator with:
    - Redundant command elimination
    - Changed-axis-only output
    - State-aware motion commands
    - 
    """ 
    def add_move(self, x: float , y: float, motion_type: str) -> list:
        """Add move command with optimized output"""            
        parts = []
        
        # Round coordinates before comparison and formatting to avoid duplicates
        x_rounded = round(x, COORD_PRECISION)
        y_rounded = round(y, COORD_PRECISION)
        
        # Add motion type if changed
        if motion_type != self.state['last_motion']:
            parts.append(motion_type)
            self.state['last_motion'] = motion_type
            
        # Add coordinates that changed
        coords = []
        if self.state['last_x'] != x_rounded:
            coords.append(f'X{x_rounded:.{COORD_PRECISION}f}'.rstrip('0').rstrip('.'))
        if self.state['last_y'] != y_rounded:
            coords.append(f'Y{y_rounded:.{COORD_PRECISION}f}'.rstrip('0').rstrip('.'))
            
        if coords:
            parts.append(GCODE_SEPARATOR.join(coords))
        elif not parts:
            # Position didn't change and motion type same - nothing to output
            return []
            
        # Update position state with rounded values
        self.state['last_x'] = x_rounded
        self.state['last_y'] = y_rounded
        
        return [GCODE_SEPARATOR.join(parts)] if parts else []

    def process_element_to_gcode(self, elements: list, viewbox_height: float) -> list:
        """Convert a single SVG element to optimized G-code commands"""
        # Reset state tracking at layer start
        self.state = {'last_x': None, 'last_y': None, 'last_motion': None}

        commands = []
        for elem in elements:
            try:
                # Get transformed path with kerf compensation
                transform = Transform(elem.composed_transform())
                path = elem.path.transform(transform)
                
                #if KERF_WIDTH > 0:
                #    path = path.offset(self.KERF_WIDTH/2)
                
                superpath = path.to_superpath()
                bezier.cspsubdiv(superpath, CURVE_SAMPLE)
                
                # Add element comment
                comment = f"; {elem.tag_name} {elem.get('id', '')} {elem.get('d')}"
                commands.append(comment[:80])
                
                for subpath in superpath:
                    if not subpath or len(subpath) < 1:
                        continue
                        
                    # Move to path start with travel move
                    x0, y0 = subpath[0][1]
                    if move_cmds := self.add_move(x0, viewbox_height - y0, 'G0'):
                        commands.extend(move_cmds)
                    
                    # Process remaining points with cutting moves
                    for point in subpath[1:]:
                        x, y = point[1]
                        if move_cmds := self.add_move(x, viewbox_height - y, 'G1'):
                            commands.extend(move_cmds)
            
            except Exception as e:
                inkex.utils.debug(f"Error processing element {elem.get('id', '')}: {str(e)}")
    
        return commands

    def process_layers(self) -> list:
        """Process all elements in all layers and return G-code commands"""
        svg = self.document.getroot()
        layers = list_layers(svg)
        viewbox_height = svg.viewbox_height

        gcode = []
        for layer in layers:
            if not is_visible(layer):
                continue

            label = get_layer_name(layer)
            if layer.get('data-active', 'false').lower() != 'true':
                continue

            passes = int(layer.get('data-passes', '1'))
            speed = int(layer.get('data-speed', '0'))
            power = int(int(layer.get('data-power', '0')) * SMAX / 100)

            elements = get_sorted_elements(layer) 
            if not elements:
                inkex.utils.debug(f"No visible elements in layer '{label}'")
                continue
            commands = self.process_element_to_gcode(elements, viewbox_height)

            gcode.append(f'; Layer: {label} | Passes: {passes} | Speed: {speed} | Power: {power/10}%')
            for p in range(passes):
                gcode.append(f'; --- {label} - Pass {p+1}/{passes}')
                gcode.append(f'G1 F{speed} S{power}')
                gcode.extend(commands)
                gcode.append(f'G0 F{TRAVEL_SPEED}')
            
        return gcode

    def effect(self) -> None:
        gcode = HEADER_GCODE.copy()
        gcode += self.process_layers()
        gcode += FOOTER_GCODE

        outpath = Path(self.document_path() or '').with_suffix('.nc')
        outpath.write_text("\n".join(gcode), encoding='utf-8')
        if DEBUG:
            inkex.utils.debug(f"GCode written to: {outpath}")

if __name__ == '__main__':
    ExportGCode().run()
